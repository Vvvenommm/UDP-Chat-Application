# just Server Leader Election
import socket
import pickle

import client
from resources import utils
from multicast import multicast_sender
from resources import utils, heartbeat

leader_address = ''
is_leader = ''
is_voting = ''


def form_ring(members):
    sorted_binary_ring = sorted([socket.inet_aton(member) for member in members])
    sorted_ip_ring = [socket.inet_ntoa(node) for node in sorted_binary_ring]
    return sorted_ip_ring  # type of sorted_ip_ring: list


def get_neighbour(members, current_member_ip, direction='left'):
    current_member_index = members.index(current_member_ip) if current_member_ip in members else -1
    if current_member_index != -1:
        if direction == 'left':
            if current_member_index + 1 == len(members):
                return members[0]
            else:
                return members[current_member_index + 1]
        else:
            if current_member_index - 1 == 0:
                return members[0]
            else:
                return members[current_member_index - 1]
    else:
        return None


ring = form_ring(utils.SERVER_LIST)
neighbour = get_neighbour(ring, utils.myIP, 'right')


def start_leader_election (address=utils.myIP):
    if not neighbour:  # wenn kein Nachbar vorhanden: eigene IP-Adresse = Leader
        set_leader(address)
        return
    global is_voting
    vote_for = max(address,
                   utils.myIP)  # wenn Nachbar vorhanden: maximum ausw√§hlen zwischen empfangener IP des Nachbarn und eigener IP Adresse
    if vote_for != utils.myIP or not is_voting:
        tcp_transmit_message('VOTE', {'vote_for': vote_for, 'leader_elected': False}, neighbour)
    is_voting = True


def set_leader(address):
    global leader_address, is_leader, is_voting
    leader_address = address
    is_leader = leader_address == utils.myIP
    is_voting = False
    if is_leader:
        print('I am the leader')
        message_to_clients('LEAD')
        if neighbour:
            tcp_transmit_message('VOTE', {'vote_for': utils.myIP, 'leader_elected': True}, neighbour)
    else:
        print(f'The leader is {leader_address}')


def ping_clients(client_to_ping=None):
    if client_to_ping:
        to_ping = [client_to_ping]
    else:
        to_ping = utils.CLIENT_LIST

    for client in to_ping:
        try:
            tcp_transmit_message('PING', '', client)
        except (ConnectionRefusedError, TimeoutError):  # If we can't connect to a client, then drop it
            print(f'Failed send to {client}')
            print(f'Removing {client} from CLIENT_LIST')
            try:
                utils.CLIENT_LIST.remove(client)
                message_to_servers('QUIT', format_join_quit('client', False, client))
                message_to_clients('SERV', f'{client[0]} is unreachable')
            except ValueError:
                print(f'{client} was not in clients')


def tcp_transmit_message(command, contents, address):
    if command != 'PING':
        print(f'Sending command {command} to {address}')
    message_bytes = encode_message(command, utils.myIP, contents)
    tcp_transmit_message(message_bytes, address)


def encode_message(command, sender, contents='', clock=None):
    message_dict = {'command': command, 'sender': sender, 'contents': contents, 'clock': clock}
    return repr(message_dict).encode()


def message_to_clients(command, contents=''):
    multicast_transmit_message(command, contents, client.name, client.port)


# Transmits multicast messages and checks how many responses are received
def multicast_transmit_message(command, contents, group):
    len_other_servers = len(utils.SERVER_LIST) - 1  # We expect responses from every other than the sender
    len_clients = len(utils.CLIENT_LIST)


# Sends tcp messages by opening a new socket, connecting, sending the message, and then closing the socket
def tcp_transmit_message(message, address):
    transmit_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    transmit_socket.settimeout(1)
    transmit_socket.connect(address)
    transmit_socket.send(message)
    transmit_socket.close()


def message_to_servers(command, contents=''):
    multicast_transmit_message(command, contents, utils.get_host_ip(), utils.SERVER_PORT)


def format_join_quit(node_type, inform_others, address):
    return {'node_type': node_type, 'inform_others': inform_others, 'address': address}

    # def start_leader_election(server_list, leader_server):
    # ring = form_ring(server_list)
    # neighbour = get_neighbour(ring, leader_server, 'right')
    # if neighbour != utils.get_host_ip():
    #   return neighbour
    # else:
    #   None
